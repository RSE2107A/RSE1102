{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Your ROS 2 and Pixy2 Project Documentation \u00b6 This site provides step-by-step instructions and setup guides for your embedded and robotic system development, including: \ud83d\udce6 Contents \u00b6 \ud83d\udee0\ufe0f Ubuntu 24.04 Installation for Raspberry Pi \ud83c\udf10 ROS2 Jazzy Installation \u2705 Pixy2 Camera Setup : Installing PixyMon, building demos, and enabling Python integration. \u2699\ufe0f UART Configuration : Setting up UART on Raspberry Pi for Pixy2 communication. \ud83e\udde0 ROS 2 Workspace : Building and sourcing your ROS 2 workspace.","title":"Home"},{"location":"#welcome-to-your-ros-2-and-pixy2-project-documentation","text":"This site provides step-by-step instructions and setup guides for your embedded and robotic system development, including:","title":"Welcome to Your ROS 2 and Pixy2 Project Documentation"},{"location":"#contents","text":"\ud83d\udee0\ufe0f Ubuntu 24.04 Installation for Raspberry Pi \ud83c\udf10 ROS2 Jazzy Installation \u2705 Pixy2 Camera Setup : Installing PixyMon, building demos, and enabling Python integration. \u2699\ufe0f UART Configuration : Setting up UART on Raspberry Pi for Pixy2 communication. \ud83e\udde0 ROS 2 Workspace : Building and sourcing your ROS 2 workspace.","title":"\ud83d\udce6 Contents"},{"location":"P1/","text":"Spin Serial Communication: Implementation Breakdown \u00b6 Spin Serial Communication Example \u00b6 This tutorial demonstrates how to implement basic serial communication on the Parallax Propeller microcontroller using the Spin language and the FullDuplexSerial object. The program waits for a byte from the serial port and prints both the character and its ASCII value to the terminal. \ud83e\uddea Objective \u00b6 Set up serial communication with the Propeller chip. Receive a byte from the user. Display the received character and its ASCII code. \ud83d\udcdc Complete Spin Code \u00b6 CON _clkmode = xtal1 + pll16x _xinfreq = 5_000_000 OBJ serial : \"FullDuplexSerial\" VAR long received PUB start serial.start(31, 30, 0, 115200) serial.str(string(\"=== P1 Ready to receive ===\", 13, 10)) repeat received := serial.rx ' Wait for byte serial.str(string(\"Received: '\")) serial.tx(received) serial.str(string(\"' (ASCII: \")) serial.dec(received) serial.str(string(\")\", 13, 10)) \u2699\ufe0f Implementation Breakdown \u00b6 1. Clock Configuration \u00b6 CON _clkmode = xtal1 + pll16x _xinfreq = 5_000_000 ```` This section sets the system clock: * `xtal1`: Selects an external crystal oscillator. * `pll16x`: Enables a 16x frequency multiplier using PLL. * `_xinfreq`: Specifies the external crystal frequency as 5 MHz. \u27a1\ufe0f Combined, this configures the Propeller's system clock to **80 MHz**. --- ### 2. Including Serial Object ```spin OBJ serial : \"FullDuplexSerial\" Imports the FullDuplexSerial object, which handles bidirectional UART communication. This object must be available in your project folder or library. 3. Declaring Variables \u00b6 VAR long received Declares a 32-bit variable named received to store the incoming byte from the serial line. 4. Starting Serial Communication \u00b6 serial.start(31, 30, 0, 115200) Initializes the serial driver: 31 : RX pin (receives data from PC) 30 : TX pin (sends data to PC) 0 : Mode setting (standard) 115200 : Baud rate 5. Sending Ready Message \u00b6 serial.str(string(\"=== P1 Ready to receive ===\", 13, 10)) Sends a string to indicate that the Propeller is ready. 13 = Carriage Return , 10 = Line Feed for newline formatting. 6. Receiving and Displaying Characters \u00b6 Wait for a character: \u00b6 repeat received := serial.rx Waits for a character to arrive from the serial interface. Stores it into the received variable. Display the character and ASCII value: \u00b6 serial.str(string(\"Received: '\")) serial.tx(received) serial.str(string(\"' (ASCII: \")) serial.dec(received) serial.str(string(\")\", 13, 10)) This part: Displays the received character. Shows its ASCII decimal value. Outputs the formatted string to the terminal. \ud83d\udcbb Example Output \u00b6 When you send characters to the Propeller from a terminal, you'll see responses like: === P1 Ready to receive === Received: 'A' (ASCII: 65) Received: 'b' (ASCII: 98) Received: '1' (ASCII: 49) \ud83d\udd0c Setup Instructions \u00b6 Wiring \u00b6 Propeller Pin 31 \u2192 USB-to-Serial RX Propeller Pin 30 \u2192 USB-to-Serial TX GND \u2192 GND Serial Terminal Settings \u00b6 Baud rate : 115200 Data : 8 bits Parity : None Stop bits : 1 Loading Code \u00b6 Use Propeller Tool or SimpleIDE to load the code onto the microcontroller.","title":"Serial Implementation"},{"location":"P1/#spin-serial-communication-implementation-breakdown","text":"","title":"Spin Serial Communication: Implementation Breakdown"},{"location":"P1/#spin-serial-communication-example","text":"This tutorial demonstrates how to implement basic serial communication on the Parallax Propeller microcontroller using the Spin language and the FullDuplexSerial object. The program waits for a byte from the serial port and prints both the character and its ASCII value to the terminal.","title":"Spin Serial Communication Example"},{"location":"P1/#objective","text":"Set up serial communication with the Propeller chip. Receive a byte from the user. Display the received character and its ASCII code.","title":"\ud83e\uddea Objective"},{"location":"P1/#complete-spin-code","text":"CON _clkmode = xtal1 + pll16x _xinfreq = 5_000_000 OBJ serial : \"FullDuplexSerial\" VAR long received PUB start serial.start(31, 30, 0, 115200) serial.str(string(\"=== P1 Ready to receive ===\", 13, 10)) repeat received := serial.rx ' Wait for byte serial.str(string(\"Received: '\")) serial.tx(received) serial.str(string(\"' (ASCII: \")) serial.dec(received) serial.str(string(\")\", 13, 10))","title":"\ud83d\udcdc Complete Spin Code"},{"location":"P1/#implementation-breakdown","text":"","title":"\u2699\ufe0f Implementation Breakdown"},{"location":"P1/#1-clock-configuration","text":"CON _clkmode = xtal1 + pll16x _xinfreq = 5_000_000 ```` This section sets the system clock: * `xtal1`: Selects an external crystal oscillator. * `pll16x`: Enables a 16x frequency multiplier using PLL. * `_xinfreq`: Specifies the external crystal frequency as 5 MHz. \u27a1\ufe0f Combined, this configures the Propeller's system clock to **80 MHz**. --- ### 2. Including Serial Object ```spin OBJ serial : \"FullDuplexSerial\" Imports the FullDuplexSerial object, which handles bidirectional UART communication. This object must be available in your project folder or library.","title":"1. Clock Configuration"},{"location":"P1/#3-declaring-variables","text":"VAR long received Declares a 32-bit variable named received to store the incoming byte from the serial line.","title":"3. Declaring Variables"},{"location":"P1/#4-starting-serial-communication","text":"serial.start(31, 30, 0, 115200) Initializes the serial driver: 31 : RX pin (receives data from PC) 30 : TX pin (sends data to PC) 0 : Mode setting (standard) 115200 : Baud rate","title":"4. Starting Serial Communication"},{"location":"P1/#5-sending-ready-message","text":"serial.str(string(\"=== P1 Ready to receive ===\", 13, 10)) Sends a string to indicate that the Propeller is ready. 13 = Carriage Return , 10 = Line Feed for newline formatting.","title":"5. Sending Ready Message"},{"location":"P1/#6-receiving-and-displaying-characters","text":"","title":"6. Receiving and Displaying Characters"},{"location":"P1/#wait-for-a-character","text":"repeat received := serial.rx Waits for a character to arrive from the serial interface. Stores it into the received variable.","title":"Wait for a character:"},{"location":"P1/#display-the-character-and-ascii-value","text":"serial.str(string(\"Received: '\")) serial.tx(received) serial.str(string(\"' (ASCII: \")) serial.dec(received) serial.str(string(\")\", 13, 10)) This part: Displays the received character. Shows its ASCII decimal value. Outputs the formatted string to the terminal.","title":"Display the character and ASCII value:"},{"location":"P1/#example-output","text":"When you send characters to the Propeller from a terminal, you'll see responses like: === P1 Ready to receive === Received: 'A' (ASCII: 65) Received: 'b' (ASCII: 98) Received: '1' (ASCII: 49)","title":"\ud83d\udcbb Example Output"},{"location":"P1/#setup-instructions","text":"","title":"\ud83d\udd0c Setup Instructions"},{"location":"P1/#wiring","text":"Propeller Pin 31 \u2192 USB-to-Serial RX Propeller Pin 30 \u2192 USB-to-Serial TX GND \u2192 GND","title":"Wiring"},{"location":"P1/#serial-terminal-settings","text":"Baud rate : 115200 Data : 8 bits Parity : None Stop bits : 1","title":"Serial Terminal Settings"},{"location":"P1/#loading-code","text":"Use Propeller Tool or SimpleIDE to load the code onto the microcontroller.","title":"Loading Code"},{"location":"UART/","text":"\ud83d\udd0c UART Setup on Raspberry Pi \u00b6 These steps help you enable and use UART (serial communication) on a Raspberry Pi (or similar Linux SBC). \ud83d\udcdd 1. Edit Configuration File \u00b6 Open the boot configuration file: sudo gedit /boot/firmware/config.txt Add the following at the end of the file (after [all] section): enable_uart = 1 dtoverlay = disable-bt enable_uart=1 : Enables the UART serial interface. dtoverlay=disable-bt : Disables Bluetooth, which uses the primary UART on some Pi models. \ud83d\udc64 2. Add User to dialout Group \u00b6 sudo usermod -aG dialout $USER This allows your user account to access serial ports (e.g. /dev/ttyS0 , /dev/ttyUSB0 ). You must log out and log in again (or reboot) for the changes to apply. \ud83d\udd04 3. Reboot the Raspberry Pi \u00b6 sudo reboot Reboots the system to apply your changes. \u2705 4. After Reboot \u00b6 UART should now be available at /dev/ttyAMA0 .","title":"UART Setup"},{"location":"UART/#uart-setup-on-raspberry-pi","text":"These steps help you enable and use UART (serial communication) on a Raspberry Pi (or similar Linux SBC).","title":"\ud83d\udd0c UART Setup on Raspberry Pi"},{"location":"UART/#1-edit-configuration-file","text":"Open the boot configuration file: sudo gedit /boot/firmware/config.txt Add the following at the end of the file (after [all] section): enable_uart = 1 dtoverlay = disable-bt enable_uart=1 : Enables the UART serial interface. dtoverlay=disable-bt : Disables Bluetooth, which uses the primary UART on some Pi models.","title":"\ud83d\udcdd 1. Edit Configuration File"},{"location":"UART/#2-add-user-to-dialout-group","text":"sudo usermod -aG dialout $USER This allows your user account to access serial ports (e.g. /dev/ttyS0 , /dev/ttyUSB0 ). You must log out and log in again (or reboot) for the changes to apply.","title":"\ud83d\udc64 2. Add User to dialout Group"},{"location":"UART/#3-reboot-the-raspberry-pi","text":"sudo reboot Reboots the system to apply your changes.","title":"\ud83d\udd04 3. Reboot the Raspberry Pi"},{"location":"UART/#4-after-reboot","text":"UART should now be available at /dev/ttyAMA0 .","title":"\u2705 4. After Reboot"},{"location":"pixy2_installation/","text":"\ud83d\udce6 Pixy2 Installation Instructions (Linux) \u00b6 \ud83d\udd17 Downloads: \u00b6 Official Page: https://pixycam.com/downloads-pixy2/ GitHub Repository: https://github.com/charmedlabs/pixy2 Installing PixyMon on Linux Make sure you install this, otherwide your pixy2 will not work : https://docs.pixycam.com/wiki/doku.php?id=wiki:v2:installing_pixymon_on_linux \u2699\ufe0f System Dependencies \u00b6 Install required Qt5 and SWIG packages: sudo apt-get update sudo apt-get install qtbase5-dev qtchooser qt5-qmake qtbase5-dev-tools sudo apt-get install swig \ud83d\udc0d Set Python 3 as Default \u00b6 sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 1 \ud83d\udee0\ufe0f Build Demos and Libraries \u00b6 \ud83d\udd39 Build Python Demos \u00b6 ./build_python_demos.sh \ud83d\udd39 (Optional) Build Everything \u00b6 ./build_all.sh \ud83e\udde0 Set Python Path for Pixy2 \u00b6 echo 'export PYTHONPATH=\"/home/pj/pixy2/build/python_demos:$PYTHONPATH\"' >> ~/.bashrc source ~/.bashrc Replace /home/pj/pixy2 with your actual Pixy2 repo path.","title":"Pixy2 Installation"},{"location":"pixy2_installation/#pixy2-installation-instructions-linux","text":"","title":"\ud83d\udce6 Pixy2 Installation Instructions (Linux)"},{"location":"pixy2_installation/#downloads","text":"Official Page: https://pixycam.com/downloads-pixy2/ GitHub Repository: https://github.com/charmedlabs/pixy2 Installing PixyMon on Linux Make sure you install this, otherwide your pixy2 will not work : https://docs.pixycam.com/wiki/doku.php?id=wiki:v2:installing_pixymon_on_linux","title":"\ud83d\udd17 Downloads:"},{"location":"pixy2_installation/#system-dependencies","text":"Install required Qt5 and SWIG packages: sudo apt-get update sudo apt-get install qtbase5-dev qtchooser qt5-qmake qtbase5-dev-tools sudo apt-get install swig","title":"\u2699\ufe0f System Dependencies"},{"location":"pixy2_installation/#set-python-3-as-default","text":"sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 1","title":"\ud83d\udc0d Set Python 3 as Default"},{"location":"pixy2_installation/#build-demos-and-libraries","text":"","title":"\ud83d\udee0\ufe0f Build Demos and Libraries"},{"location":"pixy2_installation/#build-python-demos","text":"./build_python_demos.sh","title":"\ud83d\udd39 Build Python Demos"},{"location":"pixy2_installation/#optional-build-everything","text":"./build_all.sh","title":"\ud83d\udd39 (Optional) Build Everything"},{"location":"pixy2_installation/#set-python-path-for-pixy2","text":"echo 'export PYTHONPATH=\"/home/pj/pixy2/build/python_demos:$PYTHONPATH\"' >> ~/.bashrc source ~/.bashrc Replace /home/pj/pixy2 with your actual Pixy2 repo path.","title":"\ud83e\udde0 Set Python Path for Pixy2"},{"location":"ros2_jazzy_installation/","text":"Installing ROS 2 Jazzy on Ubuntu (Binary Install) \u00b6 This tutorial explains how to install ROS 2 Jazzy on Ubuntu Linux using pre-built binary packages . Note The pre-built binary does not include all ROS 2 packages . - All packages in the ROS base variant are included. - Only a subset of packages from the ROS desktop variant are included. - For the full list, refer to the ros2.repos file. - DEB packages are also available. System Requirements \u00b6 ROS 2 Jazzy currently supports: Ubuntu Noble (24.04) Architectures: 64-bit x86 (amd64) 64-bit ARM (arm64) System Setup \u00b6 1. Set Locale \u00b6 Ensure your system locale supports UTF-8. locale # Check current locale settings sudo apt update && sudo apt install locales sudo locale-gen en_US en_US.UTF-8 sudo update-locale LC_ALL = en_US.UTF-8 LANG = en_US.UTF-8 export LANG = en_US.UTF-8 locale # Verify that UTF-8 is enabled 2. Enable Required Repositories \u00b6 Enable Universe Repository \u00b6 sudo apt install software-properties-common sudo add-apt-repository universe Add ROS 2 APT Repository \u00b6 Install the ros2-apt-source package to automatically set up the ROS 2 repositories: sudo apt update && sudo apt install curl -y sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg echo \"deb [arch= $( dpkg --print-architecture ) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $( . /etc/os-release && echo $UBUNTU_CODENAME ) main\" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null sudo apt update Install ROS2 \u00b6 sudo apt install ros-jazzy-desktop-full sudo apt install ros-dev-tools source /opt/jazzy/setup.bash echo \"source /opt/ros/jazzy/setup.bash\" >> ~/.bashrc For testing installation: \u00b6 ros2 run turtlesim turtlesim_node More repository configuration steps will follow (e.g., importing GPG keys and installing ROS 2 packages). (This snippet ends here, but you can extend the markdown to include those as needed.)","title":"ROS2 Jazzy Installation"},{"location":"ros2_jazzy_installation/#installing-ros-2-jazzy-on-ubuntu-binary-install","text":"This tutorial explains how to install ROS 2 Jazzy on Ubuntu Linux using pre-built binary packages . Note The pre-built binary does not include all ROS 2 packages . - All packages in the ROS base variant are included. - Only a subset of packages from the ROS desktop variant are included. - For the full list, refer to the ros2.repos file. - DEB packages are also available.","title":"Installing ROS 2 Jazzy on Ubuntu (Binary Install)"},{"location":"ros2_jazzy_installation/#system-requirements","text":"ROS 2 Jazzy currently supports: Ubuntu Noble (24.04) Architectures: 64-bit x86 (amd64) 64-bit ARM (arm64)","title":"System Requirements"},{"location":"ros2_jazzy_installation/#system-setup","text":"","title":"System Setup"},{"location":"ros2_jazzy_installation/#1-set-locale","text":"Ensure your system locale supports UTF-8. locale # Check current locale settings sudo apt update && sudo apt install locales sudo locale-gen en_US en_US.UTF-8 sudo update-locale LC_ALL = en_US.UTF-8 LANG = en_US.UTF-8 export LANG = en_US.UTF-8 locale # Verify that UTF-8 is enabled","title":"1. Set Locale"},{"location":"ros2_jazzy_installation/#2-enable-required-repositories","text":"","title":"2. Enable Required Repositories"},{"location":"ros2_jazzy_installation/#enable-universe-repository","text":"sudo apt install software-properties-common sudo add-apt-repository universe","title":"Enable Universe Repository"},{"location":"ros2_jazzy_installation/#add-ros-2-apt-repository","text":"Install the ros2-apt-source package to automatically set up the ROS 2 repositories: sudo apt update && sudo apt install curl -y sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg echo \"deb [arch= $( dpkg --print-architecture ) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $( . /etc/os-release && echo $UBUNTU_CODENAME ) main\" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null sudo apt update","title":"Add ROS 2 APT Repository"},{"location":"ros2_jazzy_installation/#install-ros2","text":"sudo apt install ros-jazzy-desktop-full sudo apt install ros-dev-tools source /opt/jazzy/setup.bash echo \"source /opt/ros/jazzy/setup.bash\" >> ~/.bashrc","title":"Install ROS2"},{"location":"ros2_jazzy_installation/#for-testing-installation","text":"ros2 run turtlesim turtlesim_node More repository configuration steps will follow (e.g., importing GPG keys and installing ROS 2 packages). (This snippet ends here, but you can extend the markdown to include those as needed.)","title":"For testing installation:"},{"location":"ros2_ws%20%28copy%29/","text":"ros2_ws Build and Source Instructions \u00b6 Follow the steps below to build and source your ROS 2 workspace: \ud83d\udce5 1. Download ros2_ws into Your Home Folder \u00b6 If you haven\u2019t cloned or created the ros2_ws yet, do that first. Then: cd ~/ros2_ws git clone ... \ud83d\udee0 2. Build the Workspace \u00b6 colcon build \ud83d\udd01 3. Source the Setup Script \u00b6 source install/setup.bash \u2705 This step ensures your ROS 2 environment is properly configured for the current terminal session. \ud83d\udd04 4. After Code Updates \u00b6 Any time you update the code in your package, you need to : colcon build source install/setup.bash \ud83d\udd27 colcon build \u2014 Compiles and Prepares Your Code \u00b6 In ROS 2, building your workspace is essential for changes to take effect. Why It's Necessary \u00b6 ROS 2 uses CMake (for C++) and the ament build system under the hood. When you run: colcon build You are doing the following: \ud83e\uddf1 Compiling your C++ source files \ud83d\udd17 Linking or copying Python scripts and launch files \ud83d\uddc2 Generating the install/ layout , which ROS 2 uses to resolve dependencies and locate packages \u26a0\ufe0f If you don\u2019t run colcon build , ROS 2 will not detect any of your new code, files, or updates. \ud83e\udde0 Important Note (Python Users Too!) \u00b6 Even if your project is written entirely in Python (which is not compiled), you still need to run colcon build . Here's why: It ensures that the install/ directory is properly updated. ROS 2 tools like ros2 run and ros2 launch look for packages in the install/ tree. \ud83d\udccc Summary \u00b6 Action Purpose colcon build Rebuilds your workspace, regenerates install layout source install/setup.bash Makes newly built packages available to ROS 2 commands After colcon build , always remember to: source install/setup.bash This activates your latest build and registers it with your current terminal session.","title":"ros2_ws Build and Source Instructions"},{"location":"ros2_ws%20%28copy%29/#ros2_ws-build-and-source-instructions","text":"Follow the steps below to build and source your ROS 2 workspace:","title":"ros2_ws Build and Source Instructions"},{"location":"ros2_ws%20%28copy%29/#1-download-ros2_ws-into-your-home-folder","text":"If you haven\u2019t cloned or created the ros2_ws yet, do that first. Then: cd ~/ros2_ws git clone ...","title":"\ud83d\udce5 1. Download ros2_ws into Your Home Folder"},{"location":"ros2_ws%20%28copy%29/#2-build-the-workspace","text":"colcon build","title":"\ud83d\udee0 2. Build the Workspace"},{"location":"ros2_ws%20%28copy%29/#3-source-the-setup-script","text":"source install/setup.bash \u2705 This step ensures your ROS 2 environment is properly configured for the current terminal session.","title":"\ud83d\udd01 3. Source the Setup Script"},{"location":"ros2_ws%20%28copy%29/#4-after-code-updates","text":"Any time you update the code in your package, you need to : colcon build source install/setup.bash","title":"\ud83d\udd04 4. After Code Updates"},{"location":"ros2_ws%20%28copy%29/#colcon-build-compiles-and-prepares-your-code","text":"In ROS 2, building your workspace is essential for changes to take effect.","title":"\ud83d\udd27 colcon build \u2014 Compiles and Prepares Your Code"},{"location":"ros2_ws%20%28copy%29/#why-its-necessary","text":"ROS 2 uses CMake (for C++) and the ament build system under the hood. When you run: colcon build You are doing the following: \ud83e\uddf1 Compiling your C++ source files \ud83d\udd17 Linking or copying Python scripts and launch files \ud83d\uddc2 Generating the install/ layout , which ROS 2 uses to resolve dependencies and locate packages \u26a0\ufe0f If you don\u2019t run colcon build , ROS 2 will not detect any of your new code, files, or updates.","title":"Why It's Necessary"},{"location":"ros2_ws%20%28copy%29/#important-note-python-users-too","text":"Even if your project is written entirely in Python (which is not compiled), you still need to run colcon build . Here's why: It ensures that the install/ directory is properly updated. ROS 2 tools like ros2 run and ros2 launch look for packages in the install/ tree.","title":"\ud83e\udde0 Important Note (Python Users Too!)"},{"location":"ros2_ws%20%28copy%29/#summary","text":"Action Purpose colcon build Rebuilds your workspace, regenerates install layout source install/setup.bash Makes newly built packages available to ROS 2 commands After colcon build , always remember to: source install/setup.bash This activates your latest build and registers it with your current terminal session.","title":"\ud83d\udccc Summary"},{"location":"ros2_ws/","text":"ROS2 Python Package for Pixy2 Detection: pixy2_uart_pkg \u00b6 Introduction \u00b6 pixy2_uart_pkg is a Python ROS 2 Jazzy package that interfaces with the Pixy2 vision sensor via UART communication. It initializes the Pixy2 using the Pixy SDK, reads detected object blocks at 10 Hz, publishes the block count on a ROS 2 topic ( /pixy_block_count ), and sends the count over UART to an external device. This package allows ROS 2 applications to integrate Pixy2 sensor data and communicate with external hardware using UART. Prerequisites \u00b6 ROS 2 Jazzy installed and properly sourced Pixy2 SDK and Python bindings installed python3-serial Python package installed for UART communication A Pixy2 sensor connected to the UART port /dev/ttyAMA0 or update accordingly Installation of python3-serial \u00b6 sudo apt update sudo apt install python3-serial Setup Guide \u00b6 1. Setup ROS 2 Jazzy environment \u00b6 Open a terminal and source your ROS 2 Jazzy installation: source /opt/ros/jazzy/setup.bash ```` ### 2. Create a ROS 2 workspace (if you don\u2019t have one) ``` bash mkdir -p ~/ros2_ws/src cd ~/ros2_ws colcon build source install/setup.bash 3. Create the Python package inside the workspace \u00b6 cd ~/ros2_ws/src ros2 pkg create --build-type ament_python pixy2_uart_pkg This creates the package folder structure with essential setup files. 4. Add the node script \u00b6 Inside the package folder, create pixy2_uart_node.py under pixy2_uart_pkg/ with the following content: #!/usr/bin/env python3 import rclpy from rclpy.node import Node from std_msgs.msg import Int32 import pixy from pixy import * from ctypes import * import serial import time class PixyUARTNode ( Node ): def __init__ ( self ): super () . __init__ ( 'pixy_uart_publisher' ) # ROS 2 publisher self . publisher_ = self . create_publisher ( Int32 , 'pixy_block_count' , 10 ) # Pixy2 init self . get_logger () . info ( \"Initializing Pixy2...\" ) pixy . init () pixy . change_prog ( \"color_connected_components\" ) # UART init try : self . uart = serial . Serial ( '/dev/ttyAMA0' , baudrate = 115200 , timeout = 1 ) self . get_logger () . info ( \"UART connected on /dev/ttyAMA0\" ) except serial . SerialException as e : self . get_logger () . error ( f \"Failed to open UART port: { e } \" ) self . uart = None # Block buffer self . blocks = BlockArray ( 100 ) self . frame = 0 # Timer: 10 Hz self . timer = self . create_timer ( 0.1 , self . timer_callback ) def timer_callback ( self ): count = pixy . ccc_get_blocks ( 100 , self . blocks ) if count > 0 : self . get_logger () . info ( f 'Frame { self . frame } - Detected { count } blocks' ) self . frame += 1 # Publish block count msg = Int32 () msg . data = count self . publisher_ . publish ( msg ) # Send via UART if self . uart : try : self . uart . write ( bytes ([ count ])) # send as a single byte except Exception as e : self . get_logger () . warn ( f \"UART write error: { e } \" ) def main ( args = None ): rclpy . init ( args = args ) node = PixyUARTNode () try : rclpy . spin ( node ) except KeyboardInterrupt : node . get_logger () . info ( 'Shutting down.' ) finally : if node . uart : node . uart . close () node . destroy_node () rclpy . shutdown () if __name__ == '__main__' : main () Make sure the script is executable: chmod +x ~/ros2_ws/src/pixy2_uart_pkg/pixy2_uart_pkg/pixy2_uart_node.py 5. Edit setup.py \u00b6 Modify the setup.py file in the pixy2_uart_pkg folder to register the node as a console script: from setuptools import setup package_name = 'pixy2_uart_pkg' setup ( name = package_name , version = '0.0.0' , packages = [ package_name ], install_requires = [ 'setuptools' , 'pyserial' ], zip_safe = True , maintainer = 'Your Name' , maintainer_email = 'your.email@example.com' , description = 'Python package for Pixy2 UART communication in ROS 2 Jazzy' , license = 'Apache License 2.0' , tests_require = [ 'pytest' ], entry_points = { 'console_scripts' : [ 'pixy2_uart_node = pixy2_uart_pkg.pixy2_uart_node:main' , ], }, ) 6. Build the workspace \u00b6 Go to the root of your workspace and build with colcon: cd ~/ros2_ws colcon build 7. Source your workspace \u00b6 After building, source your workspace overlay: source install/setup.bash 8. Run the Pixy2 UART node \u00b6 Run your node with: ros2 run pixy2_uart_pkg pixy2_uart_node You should see log messages indicating Pixy2 initialization, block detections, and UART transmissions. Notes \u00b6 Adjust UART device path ( /dev/ttyAMA0 ) if your hardware uses a different port. Ensure Pixy2 SDK Python bindings and python3-serial are installed in your environment. This node publishes the detected block count as a standard Int32 ROS 2 message, which can be subscribed to by other nodes. License \u00b6 This project is licensed under the Apache License 2.0.","title":"ROS2 Workspace and Package"},{"location":"ros2_ws/#ros2-python-package-for-pixy2-detection-pixy2_uart_pkg","text":"","title":"ROS2 Python Package for Pixy2 Detection: pixy2_uart_pkg"},{"location":"ros2_ws/#introduction","text":"pixy2_uart_pkg is a Python ROS 2 Jazzy package that interfaces with the Pixy2 vision sensor via UART communication. It initializes the Pixy2 using the Pixy SDK, reads detected object blocks at 10 Hz, publishes the block count on a ROS 2 topic ( /pixy_block_count ), and sends the count over UART to an external device. This package allows ROS 2 applications to integrate Pixy2 sensor data and communicate with external hardware using UART.","title":"Introduction"},{"location":"ros2_ws/#prerequisites","text":"ROS 2 Jazzy installed and properly sourced Pixy2 SDK and Python bindings installed python3-serial Python package installed for UART communication A Pixy2 sensor connected to the UART port /dev/ttyAMA0 or update accordingly","title":"Prerequisites"},{"location":"ros2_ws/#installation-of-python3-serial","text":"sudo apt update sudo apt install python3-serial","title":"Installation of python3-serial"},{"location":"ros2_ws/#setup-guide","text":"","title":"Setup Guide"},{"location":"ros2_ws/#1-setup-ros-2-jazzy-environment","text":"Open a terminal and source your ROS 2 Jazzy installation: source /opt/ros/jazzy/setup.bash ```` ### 2. Create a ROS 2 workspace (if you don\u2019t have one) ``` bash mkdir -p ~/ros2_ws/src cd ~/ros2_ws colcon build source install/setup.bash","title":"1. Setup ROS 2 Jazzy environment"},{"location":"ros2_ws/#3-create-the-python-package-inside-the-workspace","text":"cd ~/ros2_ws/src ros2 pkg create --build-type ament_python pixy2_uart_pkg This creates the package folder structure with essential setup files.","title":"3. Create the Python package inside the workspace"},{"location":"ros2_ws/#4-add-the-node-script","text":"Inside the package folder, create pixy2_uart_node.py under pixy2_uart_pkg/ with the following content: #!/usr/bin/env python3 import rclpy from rclpy.node import Node from std_msgs.msg import Int32 import pixy from pixy import * from ctypes import * import serial import time class PixyUARTNode ( Node ): def __init__ ( self ): super () . __init__ ( 'pixy_uart_publisher' ) # ROS 2 publisher self . publisher_ = self . create_publisher ( Int32 , 'pixy_block_count' , 10 ) # Pixy2 init self . get_logger () . info ( \"Initializing Pixy2...\" ) pixy . init () pixy . change_prog ( \"color_connected_components\" ) # UART init try : self . uart = serial . Serial ( '/dev/ttyAMA0' , baudrate = 115200 , timeout = 1 ) self . get_logger () . info ( \"UART connected on /dev/ttyAMA0\" ) except serial . SerialException as e : self . get_logger () . error ( f \"Failed to open UART port: { e } \" ) self . uart = None # Block buffer self . blocks = BlockArray ( 100 ) self . frame = 0 # Timer: 10 Hz self . timer = self . create_timer ( 0.1 , self . timer_callback ) def timer_callback ( self ): count = pixy . ccc_get_blocks ( 100 , self . blocks ) if count > 0 : self . get_logger () . info ( f 'Frame { self . frame } - Detected { count } blocks' ) self . frame += 1 # Publish block count msg = Int32 () msg . data = count self . publisher_ . publish ( msg ) # Send via UART if self . uart : try : self . uart . write ( bytes ([ count ])) # send as a single byte except Exception as e : self . get_logger () . warn ( f \"UART write error: { e } \" ) def main ( args = None ): rclpy . init ( args = args ) node = PixyUARTNode () try : rclpy . spin ( node ) except KeyboardInterrupt : node . get_logger () . info ( 'Shutting down.' ) finally : if node . uart : node . uart . close () node . destroy_node () rclpy . shutdown () if __name__ == '__main__' : main () Make sure the script is executable: chmod +x ~/ros2_ws/src/pixy2_uart_pkg/pixy2_uart_pkg/pixy2_uart_node.py","title":"4. Add the node script"},{"location":"ros2_ws/#5-edit-setuppy","text":"Modify the setup.py file in the pixy2_uart_pkg folder to register the node as a console script: from setuptools import setup package_name = 'pixy2_uart_pkg' setup ( name = package_name , version = '0.0.0' , packages = [ package_name ], install_requires = [ 'setuptools' , 'pyserial' ], zip_safe = True , maintainer = 'Your Name' , maintainer_email = 'your.email@example.com' , description = 'Python package for Pixy2 UART communication in ROS 2 Jazzy' , license = 'Apache License 2.0' , tests_require = [ 'pytest' ], entry_points = { 'console_scripts' : [ 'pixy2_uart_node = pixy2_uart_pkg.pixy2_uart_node:main' , ], }, )","title":"5. Edit setup.py"},{"location":"ros2_ws/#6-build-the-workspace","text":"Go to the root of your workspace and build with colcon: cd ~/ros2_ws colcon build","title":"6. Build the workspace"},{"location":"ros2_ws/#7-source-your-workspace","text":"After building, source your workspace overlay: source install/setup.bash","title":"7. Source your workspace"},{"location":"ros2_ws/#8-run-the-pixy2-uart-node","text":"Run your node with: ros2 run pixy2_uart_pkg pixy2_uart_node You should see log messages indicating Pixy2 initialization, block detections, and UART transmissions.","title":"8. Run the Pixy2 UART node"},{"location":"ros2_ws/#notes","text":"Adjust UART device path ( /dev/ttyAMA0 ) if your hardware uses a different port. Ensure Pixy2 SDK Python bindings and python3-serial are installed in your environment. This node publishes the detected block count as a standard Int32 ROS 2 message, which can be subscribed to by other nodes.","title":"Notes"},{"location":"ros2_ws/#license","text":"This project is licensed under the Apache License 2.0.","title":"License"},{"location":"ubuntu24/","text":"\ud83d\udc27 Ubuntu 24.04 Installation for Raspberry Pi 4B and Above \u00b6 This guide will help you install Ubuntu 24.04 (Noble Numbat) on Raspberry Pi 4B, 400, or 5. \ud83e\uddf0 Requirements \u00b6 Raspberry Pi 4B, 400, or 5 microSD card (32GB+ recommended, Class 10 or UHS-1) SD card reader Computer with internet access USB keyboard and mouse HDMI monitor and cable \ud83d\udce5 Installation Instruction \u00b6 How to Install Ubuntu 24.04 LTS on Raspberry Pi Through Raspberry Pi Imager: \ud83d\udd17 https://greenwebpage.com/community/how-to-install-ubuntu-24-04-lts-on-raspberry-pi/ Go to the official Ubuntu download page: \ud83d\udd17 https://ubuntu.com/download/raspberry-pi After follwing instruction above, you can boot up your Raspberry Pi with your SD card inserted to the SD Card Port. Then, you can follow following set to install the Ubuntu System. Starting from item 4 at Once the installer has initialised, you are invited to choose your language. \ud83d\udd17 https://ubuntu.com/tutorials/install-ubuntu-desktop#4-boot-from-usb-flash-drive","title":"Ubuntu24.04 Installation"},{"location":"ubuntu24/#ubuntu-2404-installation-for-raspberry-pi-4b-and-above","text":"This guide will help you install Ubuntu 24.04 (Noble Numbat) on Raspberry Pi 4B, 400, or 5.","title":"\ud83d\udc27 Ubuntu 24.04 Installation for Raspberry Pi 4B and Above"},{"location":"ubuntu24/#requirements","text":"Raspberry Pi 4B, 400, or 5 microSD card (32GB+ recommended, Class 10 or UHS-1) SD card reader Computer with internet access USB keyboard and mouse HDMI monitor and cable","title":"\ud83e\uddf0 Requirements"},{"location":"ubuntu24/#installation-instruction","text":"How to Install Ubuntu 24.04 LTS on Raspberry Pi Through Raspberry Pi Imager: \ud83d\udd17 https://greenwebpage.com/community/how-to-install-ubuntu-24-04-lts-on-raspberry-pi/ Go to the official Ubuntu download page: \ud83d\udd17 https://ubuntu.com/download/raspberry-pi After follwing instruction above, you can boot up your Raspberry Pi with your SD card inserted to the SD Card Port. Then, you can follow following set to install the Ubuntu System. Starting from item 4 at Once the installer has initialised, you are invited to choose your language. \ud83d\udd17 https://ubuntu.com/tutorials/install-ubuntu-desktop#4-boot-from-usb-flash-drive","title":"\ud83d\udce5 Installation Instruction"}]}